"""
Module for evaluating Grad-CAM performance in pneumonia detection.

This script evaluates the Intersection over Union (IoU) of predicted bounding boxes generated by
Grad-CAM against ground truth boxes from the RSNA Pneumonia Detection Challenge dataset. It processes
DICOM images, computes IoU scores, saves results to a CSV file, and generates visualisations with
predicted and ground truth boxes overlaid for a subset of images. The script uses a pre-trained
PneumoniaClassifier model and supports real-time evaluation on a GPU or CPU.

Key functionalities include loading DICOM images, extracting ground truth annotations, calculating IoU
scores, and saving visualisations for analysis. The script is designed to handle errors gracefully and
provide progress updates during processing.

Author: Rohman Hawrylak
Date: April 2025
"""

import os
import torch
from PIL import Image
import pydicom
import pandas as pd
import numpy as np
import cv2
from classifier import PneumoniaClassifier

# Define file paths for data, model, and output
data_dir = "/vol/scratch/SoC/misc/2024/sc21r2h/rsna_data/train_images"
csv_path = "/vol/scratch/SoC/misc/2024/sc21r2h/rsna_data/labels/stage_2_train_labels.csv"
model_path = "Training/UCSD/model_RSNA.pth"
output_dir = "evaluation_images_and_data/RSNA_Model/gradcam_eval"

# Create output directory if it does not exist
os.makedirs(output_dir, exist_ok=True)

# Load the RSNA labels from CSV
labels_df = pd.read_csv(csv_path)

# Initialise the pneumonia classifier with the pre-trained model
classifier = PneumoniaClassifier(model_path=model_path)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
classifier.to(device)

def load_dicom_image(file_path):
    """
    Load a DICOM image and convert it to a PIL Image object.

    Args:
        file_path (str): Path to the DICOM file.

    Returns:
        PIL.Image: RGB image normalised to the 0-255 range.

    Raises:
        Exception: If the DICOM file cannot be read or processed.
    """
    dicom = pydicom.dcmread(file_path)
    image = dicom.pixel_array
    # Normalise pixel values to 0-255 for consistent processing
    image = (image - image.min()) / (image.max() - image.min()) * 255
    image = image.astype(np.uint8)
    # Convert greyscale to RGB by replicating the channel
    image = np.stack([image] * 3, axis=-1)
    return Image.fromarray(image)

def get_ground_truth_boxes(patient_id, labels_df):
    """
    Extract ground truth bounding boxes for a patient from the RSNA labels.

    Args:
        patient_id (str): Unique identifier for the patient.
        labels_df (pandas.DataFrame): DataFrame containing RSNA labels.

    Returns:
        list: List of dictionaries, each containing 'x', 'y', 'width', and 'height' for a bounding box.
    """
    patient_data = labels_df[labels_df['patientId'] == patient_id]
    boxes = []
    for _, row in patient_data.iterrows():
        if row['Target'] == 1:  # Include only positive pneumonia cases
            boxes.append({
                'x': int(row['x']),
                'y': int(row['y']),
                'width': int(row['width']),
                'height': int(row['height'])
            })
    return boxes

def calculate_iou(box1, box2):
    """
    Calculate the Intersection over Union (IoU) between two bounding boxes.

    Args:
        box1 (dict): Dictionary with 'x', 'y', 'width', and 'height' for the first box.
        box2 (dict): Dictionary with 'x', 'y', 'width', and 'height' for the second box.

    Returns:
        float: IoU score, or 0 if the boxes do not intersect or union area is zero.
    """
    x1_min = box1['x']
    y1_min = box1['y']
    x1_max = x1_min + box1['width']
    y1_max = y1_min + box1['height']

    x2_min = box2['x']
    y2_min = box2['y']
    x2_max = x2_min + box2['width']
    y2_max = y2_min + box2['height']

    # Calculate intersection coordinates
    inter_x_min = max(x1_min, x2_min)
    inter_y_min = max(y1_min, y2_min)
    inter_x_max = min(x1_max, x2_max)
    inter_y_max = min(y1_max, y2_max)

    # Compute intersection and union areas
    inter_area = max(0, inter_x_max - inter_x_min) * max(0, inter_y_max - inter_y_min)
    box1_area = box1['width'] * box1['height']
    box2_area = box2['width'] * box2['height']
    union_area = box1_area + box2_area - inter_area

    return inter_area / union_area if union_area > 0 else 0

def save_visualization(image, pred_boxes, gt_boxes, patient_id, output_dir):
    """
    Save an image with predicted and ground truth bounding boxes overlaid.

    Predicted boxes are drawn in green, and ground truth boxes in blue, to facilitate visual comparison.

    Args:
        image (PIL.Image): Input image.
        pred_boxes (list): List of dictionaries with predicted box coordinates.
        gt_boxes (list): List of dictionaries with ground truth box coordinates.
        patient_id (str): Unique identifier for the patient.
        output_dir (str): Directory to save the visualisation.

    Returns:
        str: Path to the saved visualisation image.
    """
    image_np = np.array(image)
    # Draw predicted boxes in green
    for box in pred_boxes:
        x, y, w, h = box['x'], box['y'], box['width'], box['height']
        cv2.rectangle(image_np, (x, y), (x + w, y + h), (0, 255, 0), 2)
    # Draw ground truth boxes in blue
    for box in gt_boxes:
        x, y, w, h = box['x'], box['y'], box['width'], box['height']
        cv2.rectangle(image_np, (x, y), (x + w, y + h), (0, 0, 255), 2)
    
    # Save the visualisation in BGR format for OpenCV compatibility
    output_path = os.path.join(output_dir, f"{patient_id}_gradcam_eval.png")
    cv2.imwrite(output_path, cv2.cvtColor(image_np, cv2.COLOR_RGB2BGR))
    return output_path

def test_gradcam_iou(num_samples=200, num_images_to_save=20):
    """
    Evaluate Grad-CAM IoU scores and save results for analysis.

    Processes a specified number of samples from the RSNA dataset, calculates IoU between predicted
    Grad-CAM bounding boxes and ground truth, saves results to a CSV file, and generates visualisations
    for a subset of images. The function handles errors, skips invalid files, and provides progress
    updates.

    Args:
        num_samples (int, optional): Number of samples to process. Defaults to 200.
        num_images_to_save (int, optional): Number of visualisations to save. Defaults to 20.

    Returns:
        None: Outputs results to CSV and saves visualisations to the output directory.
    """
    iou_scores = []
    processed_samples = 0
    data_records = []  # Store data for CSV output

    print(f"Processing {num_samples} samples...")

    # Iterate over the RSNA dataset
    for idx, row in labels_df.iterrows():
        if processed_samples >= num_samples:
            break

        patient_id = row['patientId']
        dicom_path = os.path.join(data_dir, f"{patient_id}.dcm")

        if not os.path.exists(dicom_path):
            print(f"Skipping {patient_id}: DICOM file not found")
            continue

        # Load and preprocess the DICOM image
        try:
            image = load_dicom_image(dicom_path)
        except Exception as e:
            print(f"Error loading {patient_id}: {str(e)}")
            continue

        # Retrieve ground truth boxes for pneumonia cases
        gt_boxes = get_ground_truth_boxes(patient_id, labels_df)
        if not gt_boxes:  # Skip cases without pneumonia annotations
            continue

        # Generate predictions using the classifier
        try:
            results = classifier.predict(image)
            pred_boxes = results['boxes']
        except Exception as e:
            print(f"Error predicting {patient_id}: {str(e)}")
            continue

        # Compute IoU for each predicted box
        sample_ious = []
        for pred_box in pred_boxes:
            max_iou = 0
            for gt_box in gt_boxes:
                iou = calculate_iou(pred_box, gt_box)
                max_iou = max(max_iou, iou)
            sample_ious.append(max_iou)

        # Calculate average IoU for the sample
        if sample_ious:
            avg_iou = sum(sample_ious) / len(sample_ious)
            iou_scores.append(avg_iou)
        else:
            avg_iou = 0
            print(f"Patient {patient_id} - No predicted boxes")

        # Store results for CSV
        data_records.append({
            'PatientID': patient_id,
            'PredictedBoxes': len(pred_boxes),
            'GroundTruthBoxes': len(gt_boxes),
            'AverageIoU': avg_iou,
            'PneumoniaProbability': results['probabilities']['Pneumonia']
        })

        processed_samples += 1
        if processed_samples % 50 == 0:
            print(f"Processed {processed_samples}/{num_samples} samples")

    # Summarise IoU results
    if iou_scores:
        overall_avg_iou = sum(iou_scores) / len(iou_scores)
        print(f"\nProcessed {len(iou_scores)} valid samples with pneumonia.")
        print(f"Overall Average IoU: {overall_avg_iou:.4f}")
    else:
        print("No valid IoU scores calculated.")

    # Save results to CSV
    df = pd.DataFrame(data_records)
    csv_path = os.path.join(output_dir, "gradcam_iou_results.csv")
    df.to_csv(csv_path, index=False)
    print(f"Raw data saved to {csv_path}")

    # Select and save visualisations for representative images
    if len(data_records) > num_images_to_save:
        df_sorted = df.sort_values(by='AverageIoU')
        indices = np.linspace(0, len(df_sorted) - 1, num_images_to_save, dtype=int)
        selected_records = df_sorted.iloc[indices]
        
        print(f"\nSaving {num_images_to_save} select visualizations...")
        for _, record in selected_records.iterrows():
            patient_id = record['PatientID']
            dicom_path = os.path.join(data_dir, f"{patient_id}.dcm")
            try:
                image = load_dicom_image(dicom_path)
                results = classifier.predict(image)
                pred_boxes = results['boxes']
                gt_boxes = get_ground_truth_boxes(patient_id, labels_df)
                vis_path = save_visualization(image, pred_boxes, gt_boxes, patient_id, output_dir)
                print(f"Saved visualization for {patient_id} (IoU: {record['AverageIoU']:.4f}) at {vis_path}")
            except Exception as e:
                print(f"Error saving visualization for {patient_id}: {str(e)}")

if __name__ == "__main__":
    """
    Entry point for evaluating Grad-CAM IoU performance.

    Executes the test_gradcam_iou function with default parameters to process 200 samples and save
    visualisations for 20 representative images.
    """
    test_gradcam_iou(num_samples=200, num_images_to_save=20)